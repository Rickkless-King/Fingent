"""
Report generation for Fingent.

Reports are the final output combining signals, alerts, and LLM narrative.
"""

from dataclasses import dataclass, asdict, field
from enum import Enum
from typing import Any, Optional

from fingent.core.timeutil import format_timestamp, now_utc


class ReportType(str, Enum):
    """Report type enumeration."""
    DAILY = "daily"
    INTRADAY = "intraday"
    ALERT = "alert"
    WEEKLY = "weekly"


@dataclass
class ReportSection:
    """
    A section of the analysis report.

    Each node can contribute one or more sections.
    """
    title: str
    content: str
    section_type: str       # e.g., "macro", "cross_asset", "sentiment"
    source_node: str
    key_points: list[str] = field(default_factory=list)
    data: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "ReportSection":
        return cls(**data)


@dataclass
class Report:
    """
    Complete analysis report.

    Combines all node outputs into a structured report.
    """
    id: str
    report_type: str = ReportType.DAILY.value
    title: str = ""
    summary: str = ""           # LLM-generated executive summary
    timestamp: str = ""
    run_id: str = ""

    # Sections from each node
    sections: list[dict[str, Any]] = field(default_factory=list)

    # Aggregated data
    signals_summary: dict[str, Any] = field(default_factory=dict)
    alerts: list[dict[str, Any]] = field(default_factory=list)

    # Market snapshot
    market_snapshot: dict[str, Any] = field(default_factory=dict)

    # Metadata
    generated_by: str = "fingent"
    llm_used: bool = False

    def __post_init__(self):
        if not self.timestamp:
            self.timestamp = format_timestamp(now_utc())
        if not self.title:
            self.title = f"Fingent åˆ†ææŠ¥å‘Š - {self.timestamp[:10]}"

    def to_dict(self) -> dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "Report":
        return cls(**data)

    def to_markdown(self) -> str:
        """Convert report to Markdown format."""
        lines = [
            f"# {self.title}",
            "",
            f"*ç”Ÿæˆæ—¶é—´: {self.timestamp}*",
            "",
        ]

        # Executive summary
        if self.summary:
            lines.extend([
                "## æ‘˜è¦",
                "",
                self.summary,
                "",
            ])

        # Signals summary
        if self.signals_summary:
            direction = self.signals_summary.get("overall_direction", "neutral")
            score = self.signals_summary.get("overall_score", 0)
            direction_emoji = {
                "bullish": "ğŸŸ¢",
                "bearish": "ğŸ”´",
                "neutral": "âšª",
                "hawkish": "ğŸ¦…",
                "dovish": "ğŸ•Šï¸",
            }
            emoji = direction_emoji.get(direction, "âšª")

            lines.extend([
                "## ä¿¡å·æ±‡æ€»",
                "",
                f"**æ•´ä½“æ–¹å‘**: {emoji} {direction.upper()} (Score: {score:.2f})",
                "",
            ])

            key_signals = self.signals_summary.get("key_signals", [])
            if key_signals:
                lines.append("**å…³é”®ä¿¡å·**:")
                for sig in key_signals[:5]:
                    lines.append(f"- {sig.get('name')}: {sig.get('direction')} ({sig.get('score'):.2f})")
                lines.append("")

        # Alerts
        if self.alerts:
            lines.extend([
                "## å‘Šè­¦",
                "",
            ])
            for alert in self.alerts:
                severity_emoji = {"low": "ğŸ“¢", "medium": "âš ï¸", "high": "ğŸš¨", "critical": "ğŸ”´"}
                emoji = severity_emoji.get(alert.get("severity", "medium"), "âš ï¸")
                lines.append(f"{emoji} **{alert.get('title')}**: {alert.get('message')}")
            lines.append("")

        # Sections
        for section in self.sections:
            lines.extend([
                f"## {section.get('title', 'Section')}",
                "",
                section.get("content", ""),
                "",
            ])

            key_points = section.get("key_points", [])
            if key_points:
                lines.append("**è¦ç‚¹**:")
                for point in key_points:
                    lines.append(f"- {point}")
                lines.append("")

        # Footer
        lines.extend([
            "---",
            f"*Generated by {self.generated_by} | Run ID: {self.run_id}*",
        ])

        return "\n".join(lines)

    def to_telegram_message(self) -> str:
        """Convert report to Telegram-friendly format."""
        lines = [
            f"ğŸ“Š *{self.title}*",
            "",
        ]

        # Quick summary
        if self.signals_summary:
            direction = self.signals_summary.get("overall_direction", "neutral")
            score = self.signals_summary.get("overall_score", 0)
            lines.append(f"ğŸ¯ æ–¹å‘: *{direction.upper()}* ({score:+.2f})")
            lines.append("")

        # Summary text
        if self.summary:
            # Truncate for Telegram
            summary = self.summary[:500]
            if len(self.summary) > 500:
                summary += "..."
            lines.append(summary)
            lines.append("")

        # Active alerts
        if self.alerts:
            lines.append("ğŸš¨ *å‘Šè­¦*:")
            for alert in self.alerts[:3]:
                lines.append(f"â€¢ {alert.get('title')}")
            lines.append("")

        lines.append(f"â° {self.timestamp}")

        return "\n".join(lines)


def create_report(
    run_id: str,
    *,
    report_type: str = ReportType.DAILY.value,
    title: Optional[str] = None,
    summary: str = "",
    sections: Optional[list[dict[str, Any]]] = None,
    signals_summary: Optional[dict[str, Any]] = None,
    alerts: Optional[list[dict[str, Any]]] = None,
    market_snapshot: Optional[dict[str, Any]] = None,
    llm_used: bool = False,
) -> dict[str, Any]:
    """
    Factory function to create a report dict.

    Returns dict directly for GraphState compatibility.
    """
    timestamp = format_timestamp(now_utc())

    return {
        "id": f"report_{run_id}",
        "report_type": report_type,
        "title": title or f"Fingent åˆ†ææŠ¥å‘Š - {timestamp[:10]}",
        "summary": summary,
        "timestamp": timestamp,
        "run_id": run_id,
        "sections": sections or [],
        "signals_summary": signals_summary or {},
        "alerts": alerts or [],
        "market_snapshot": market_snapshot or {},
        "generated_by": "fingent",
        "llm_used": llm_used,
    }
